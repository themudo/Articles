#!/bin/bash
#$ -pe smp 32
#$ -N kallisto
#$ -cwd
#$ -j y
#$ -S /bin/bash
#$-l h=!(compute-0-0|compute-0-1|compute-0-2)
#$ -o kallisto-stdo.output
#$ -e kallisto-stderr.output

sample=$1
#sample=GI120CTRL
dir=./analise/${sample}
mkdir -p $dir
data_dir=./grinnaqua/data

#read1=${sample}_R1.fastq.gz
read1=$2
#read1=GI120CTRL_EKRN230044313-1A_HHN55DSX7_L2_1.fq.gz
F1=${read1##*/}
fastq1=${F1%%.*} 
#read2=${sample}_R2.fastq.gz
read2=$3
#read2=GI120CTRL_EKRN230044313-1A_HHN55DSX7_L2_2.fq.gz
F2=${read2##*/}
fastq2=${F2%%.*} 
transcriptome=./genomes/Oncorhynchus_mykiss.USDA_OmykA_1.1.cdna.all.fa.gz

echo "Starting analysis for "
echo $sample

#Check if fastqc output file already exists. If not, run fastqc.
FASTQC1=${dir}/${fastq1}_fastqc.html
FASTQC2=${dir}/${fastq2}_fastqc.html

if test -f "$FASTQC1"; then 
	echo 'Fastqc for read 1 already done; skipping'
else 
	singularity exec /share/apps/singularity/orca-3.simg fastqc -o ${dir} ${data_dir}/${sample}/${read1} 
#	singularity exec /share/apps/singularity/orca-3.simg fastqc -o ${dir} ${data_dir}/${sample}/${read1} | parallel -j 32 --verbose
fi

if test -f "$FASTQC2" ; then
	echo 'Fastqc for read 2 already done; skipping'
else 
	singularity exec /share/apps/singularity/orca-3.simg fastqc -o ${dir} ${data_dir}/${sample}/${read2}
#	singularity exec /share/apps/singularity/orca-3.simg fastqc -o ${dir} ${data_dir}/${sample}/${read2} | parallel -j 32 --verbose
fi
#fastqc ${sample}_R1.fastq.gz
#fastqc ${sample}_R2.fastq.gz
#fastqc $sample1
#fastqc $sample2

#fastqc *fastq.gz

#Two files will be generated by FastQC: fastqc.zip and fastqc.html. To visualise them, the easiest way is to open the html files with a web browser. You can find output examples in the webpage of [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/). RNA-Seq data usually present warnings for some of the categories, such as "Per base sequence context" or "Sequence duplication levels". As long as the issues are not extrime, this is normal and nothing to worry about.
#This quality control is just to visually inspect the quality of the sequencing data, but it does not alter the fastq files in any way. In fact, this step can even be skipped, although it is worth practice to check the quality of the sequencing output to discards any problems connected to RNA extraction, library preparation or sequencing.

## 2. Filtering using fastp
#While not absolutely necessary, removing low quality reads and bases can improve downstream results. (Note from GonÃ§alo, fastp also removes adapter sequences, so I think this step should not be optional) 
#[Fastp](https://github.com/OpenGene/fastp) can rapidly filter fastq files, removing low quality reads, contaminating sequence, low complexity reads (repeats), short reads, etc. An example command would be:

#fastp -i sampleA_1.fastq.gz -I sampleA_2.fastq.gz -o sampleA_filtered_1.fastq.gz -O sampleA_filtered_2.fastq.gz -q 15 -l 30 -h sampleA.html

#Check if output already exists, otherwise run fastp
FILTERED1=${dir}/${read1}_filtered.fastq.gz
FILTERED2=${dir}/${read2}_filtered.fastq.gz
if [[ -f "$FILTERED1" && -f "$FILTERED2" ]]; then
	echo 'Filtered reads already exist; skipping fastp'
else
	singularity exec /share/apps/singularity/fastp_v0.23.4.sif fastp -i ${data_dir}/${sample}/${read1} -I ${data_dir}/${sample}/${read2} -o $FILTERED1 -O $FILTERED2 -q 15 -l 30 -h ${sample}.html
	mv fastp.json ${dir}/${sample}_fastp.json
fi
#Fastp takes two paired fastq files (options -i and -I) and removes bases with Phred quality below 15 (-q 15) and reads that end up with a lenght of less than 30 bases (-l 30). The raw files remain intact, and two new filtered files are generated (options -o and -O). -h specifies names for the html file with plots showing the read quality before and after filtering  (potential alternative to FastQC).

## 3. Quantification using kallisto

#[Kallisto](https://pachterlab.github.io/kallisto/about) is a software for rapidly quantifying abundances of transcripts from RNA-seq data. It is based on a pseudoalignment strategy using the transcriptome of a species as reference. This reference transcriptome needs to be downloaded and indexed before expression can be quantified. Transcriptomes for species with sequenced genomes can be obtained from Ensembl or NCBI (and downloaded using "wget").

#To create the index of the transcriptome, the command is:
INDEX=${transcriptome}.idx

if [[ -f "$INDEX" ]]; then
	echo 'Transcriptome index already exists; skipping'
else
	kallisto index --threads 32 -i $INDEX ${transcriptome}
fi

#To estimate the expression of each transcript in each sample, we use the `quant` function of kallisto:

ABUNDANCE=${dir}/abundance.h5

if [[ -f "$ABUNDANCE" ]]; then
	echo 'Kallisto already run on this sample; skipping'
else
	kallisto quant --threads 32  -i $INDEX -o $sample -b 100 $FILTERED1 $FILTERED2 2> ${sample}_kallisto.out
fi

#The results for each sample will be in a separate folder with the name of the sample (-o). That folder will contain three files: abundance.h5, abundance.tsv, and run_info.json

echo "Finished processing "
echo $sample
